
# UML?

Unified Modeling Language (UML). Es un lenguaje para hacer dibujos de dise√±o t√©cnico de sistemas principalmente de software. Va muy orientado, sobre todo algunos tipos de diagramas a sistemas orientados a objetos.

La especificaci√≥n de UML nace de la organizaci√≥n Object Management Group (OMG) en 1997. Desde entonces ha tenido varias versiones, la √∫ltima es UML 2.5.1 de 2017.

Eso es.. hace casi 30 a√±os! Qu√© tal le va al UML?

## Historia del UML

Cuando sale estop del UML nos volvemos locos con ello.
En esa √©poca, mont√°bamos los sistema de forma muy diferente a como lo hacemos hoy en d√≠a:
- Metodolog√≠as en cascada: REQUISITOS -> AN√ÅLISIS -> "DISE√ëO" del sistema en su conjunto (semanas/meses)
- Proyectos con arquitecturas monol√≠ticas: Sistemas enormes, con cientos de clases (o miles) que evidentemente necesitaban un dise√±o previo muy detallado, sino de una forma de comunicar el dise√±o a todo el equipo.
- Equipos grandes: Equipos de decenas o cientos de personas, donde la comunicaci√≥n del dise√±o era fundamental.
- Hab√≠a cierta obsesi√≥n con el papel / documentaci√≥n: Los documentos de dise√±o eran muy importantes, y se esperaba que estuvieran bien detallados y completos (Normativas muy estrictas en algunos sectores como el aeroespacial, defensa, etc) + ITIL y CMMI.

Crear√≥n herramienats para trabajar con UML, como Rational Rose (de Rational Software, luego comprada por IBM), Visual Paradigm, Enterprise Architect, etc. UN TOSTON DESCOMUNAL DE HERRAMIENTAS. Complejas, tediosas, caras.

Hacer diagramas era un proceso LENTO (como cajitas en un power point). Adem√°s, el mantenimiento era complejo.
Una cosa es un dise√±o... y otra cosa es el c√≥digo final. Mantener ambos sincronizados era una tarea tit√°nica.

Y esas herramienats intentaban hacer ese trabajo... mantener el dise√±o y el c√≥digo sincronizados.
Eso era una ruina: Porque no hac√≠amos los diagramas para ser entendidos por humanos, sino para que las herramientas pudieran generar c√≥digo o mantener el dise√±o sincronizado con el c√≥digo. Y los humanos cuando hablamos tenemos una laxitud enorme en las gram√°ticas (nos las pasamos continuamente por las narices). Las herramientas no (son muy puntillosas con la sintaxis).

Todo eso hizo que poco a poco, sobre todo con los cambios de paradigma que nos fuimos encontrando (metodolog√≠as √°giles, arquitecturas orientadas a componentes desacoplados, equipos m√°s peque√±os, etc) el UML fuera perdiendo peso en el desarrollo de software. 

De hecho, muchas de esas herramientas complejas de UML han ido desapareciendo... las pocas que quedan est√°n totalmente desactualizadas y obsoletas. Microsoft ten√≠a soporte para UML dentro de Visual Studio... y lo quitaron hace a√±os.

Hab√≠a ilusi√≥n.. y burbuja! Pero ilusi√≥n. Cubr√≠a un hueco, una necesidad real. La forma de llevar estos diagramas a la pr√°ctica era mala, y UML fue muriendo. Se qued√≥ simplemente como una an√©cdota que seguian ense√±ando en las universidades. Y 3 ideas de diagramas que en algunos proyectos muy concretos se segu√≠an usando.

Esa es parte de la realidad... parte de la historia. Porque ahora hay otra parte!

UML se est√° redescubriendo... Y estamos empezando a usarlo un huevo! Much√≠simo! Cas√≠ m√°s que antes, en sus momentos de esplendor y gloria.

## ¬øQu√© ha pasado?

- La primera cosa que ha pasado es que hoy en d√≠a no estamos ya en el mundo de los monolitos dinosaurios. Hoy en d√≠a los sistemas son mucho m√°s peque√±os, modulares, desacoplados. Y montar esos diagramas es mucho m√°s sencillo.
- La segunda cosa que ha pasado es que las metodolog√≠as √°giles han cambiado la forma de trabajar:
  - Ya no hacemos un dise√±o del sistema completo al principio del proyecto. Voy creando, poco a poco.. y voy haciendo hacemos dise√±os de componentes peque√±os, que encajan en el sistema global.
  - No hacemos los documentos para programas. Eso de crear un diagrama de clases.. y que desde ese diagrama se genere c√≥digo JAVA... en serio?
  - A la documentaci√≥n hoy en d√≠a le damos mucha menos importancia. Hacemos diagramas para entendernos entre humanos, diagramas "light".
- Las herramientas que tenemos hoy en d√≠a, han cambiado un huevo. <<< CLAVE!

## Herramientas guays

Todas las herramientas guays.. y motivo principal para que hoy en d√≠a estemos tan encantados con UML son las herramientas que me permiten "escribir" diagramas.
Las herramientas antiguas me permit√≠an "dibujar" diagramas. Y dibujar es lento, tedioso, pesado.
Hoy en d√≠a, los diagramas los escribimos. 
Tenemos lenguajes que nos permiten escribir diagramas compatibles con UML de forma r√°pida y sencilla.

Es m√°s... hoy en d√≠a (Diciembre 2025) ni nos molestamos en escribir esos diagramas. Tenemos ayudantes (baratitos, poco coste de SS y de n√≥minas) que adem√°s escriben mucho mejor que nosotros: IAs.

Muchas de esas herramientas son expertas en escribir en lenguajes (LLM). Pero no solo eso, sino que son a√∫n m√°s expertas en usar lenguajes formales.

Pero se junta con otro factor. Hoy en d√≠a, los diagrams los escribimos para seres humanos. Y los seres humanos tenemos una capacidad creativa y de interpretaci√≥n brutal. Podemos entender diagramas que no son 100% correctos (se ajuste perfectamente a la gram√°tica UML), que tienen errores, que no siguen las reglas al pie de la letra.

Y es lo que buscamos hoy en d√≠a con los diagramas. Una forma de facilitar la comunicaci√≥n entre humanos. No buscamos generar c√≥digo, ni mantener sincronizados los diagramas con el c√≥digo.

No quiero ser el Shakespeare de los diagramas UML... ni el Cervantes de los diagramas UML. Quiero ser un tipo que hace diagramas UML r√°pidos, sencillos, sin complicarme... pisoteando la gram√°tica si es necesario.. o si no conozco ciertas cosas... pero al final diagramas que me ayuden a comunicarme EFICAZMENTE con mis compa√±eros / clientes.

No nos obsesionesmos con la perfecci√≥n. Busquemos la eficacia.

La idea all final es estandarizar la forma en la que pintamos esos diagramas. Y UML es un est√°ndar aceptado por todo el mundo. Oye.. como todo lenguaje, con sus reglas gramaticales.. es complejo.. tiene muchas triqui√±uelas... pero.. tampoco necesito ser el Shakespeare de UML para poder comunicarme de forma eficaz y eficiente con mis compa√±eros.

Las 2 herramienats que hoy en d√≠a adoramos para la creaci√≥n de diagramas UML son:
- Mermaid.js: https://mermaid-js.github.io/mermaid/#/
- PlantUML: https://plantuml.com/es/

Ambas son librer√≠as que ofrecen un lenguaje para escribir diagramas.
- Mermaid permite hacer muchos diagramas, no solo UML. Y no permite hacer todos los diagramas que define el estandar UML.
- PlantUML est√° mucho m√°s orientado al estandar UML, y permite hacer todos los diagramas UML. Pero son m√°s feos. Y el lenguaje es un poco m√°s √°spero.

Decisi√≥n 1: Si puedo hacer el diagrama que quiero hacer con Mermaid, uso Mermaid. Si no, uso PlantUML.

---

## Documentaci√≥n

La documentaci√≥n en los proyectos de software tambi√©n ha ido evolucionando un huevo!
Antiguamente escrib√≠amos "tochos" de documentaci√≥n en Word, o en herramientas de documentaci√≥n complejas (como DOORS, etc). Documentos enormes, pesados, dif√≠ciles de mantener. RUINA !!! Ya lo aprendimos!

Cu√°l es el estandar hoy en d√≠a para documentaci√≥n t√©cnica en proyectos de software? Qu√© uso para documentar? MARKDOWN!

Es un lenguaje que me permite escribir documentaci√≥n. Sin florituras, sin complicaciones. Simplemente texto plano con algunas reglas sencillas para dar formato.

La documentaci√≥n se guarda con el c√≥digo, en el repo, que es donde tiene que estar. Y cuando alguien entra al repo, ve la documentaci√≥n formateada de forma autom√°tica.

---

# Para sirven los gr√°ficos?

- Para facilitar la comunicaci√≥n entre humanos.
- Y al crear un DTE, vamos en capas... poco a poco.

En general al comenzar un proyecto de software, vamos poco a poco.
¬øCu√°l es el primer obstaculo al que nos enfrentamos cuando empezamos a dise√±oar un sistema de software?

- Sincronizar mi lenguaje con el del cliente / usuarios.
- Una vez sincronizados los lenguajes, entender bien qu√© es lo que quieren / necesitan (bajo de nivel)
- Una vez entendido qu√© es lo que quieren / necesitan, empiezo a plantear un sistema que lo satisfaga.
- Una vez planteado el sistema, empiezo a dise√±ar los componentes del sistema.

No empiezo un proyecto montando el diagrama de clases del sistema. Eso es una locura. Si posiblemente a√∫n ni siquiera s√© qu√© es lo que quieren los usuarios.

- Diagrama de casos de uso (use case diagram): Primer diagrama que hago. Me ayuda a entender qui√©nes son los actores del sistema, y qu√© necesitan del sistema.
- Diagrama de actividades (activity diagram): Me ayuda a entender los procesos / flujos de trabajo que los actores quieren llevar a cabo con el sistema.
- Diagrama de secuencia (sequence diagram): Me ayuda a entender c√≥mo interact√∫an los actores con el sistema, y c√≥mo se comporta el sistema ante esas interacciones.
- Diagrama de componentes/paquetes (component diagram): Me ayuda a entender los componentes del sistema, y c√≥mo se relacionan entre s√≠.
- Diagrama de clases (class diagram): Me ayuda a entender la estructura est√°tica del sistema, las clases, atributos, m√©todos y relaciones entre clases.
- Diagrama de m√°quinas de estado (state machine diagram): Me ayuda a entender los estados por los que puede pasar un objeto del sistema, y c√≥mo cambia de estado ante ciertos eventos.

Otra cosa importante a la hora de crear diagramas, que ha cambiado mucho en los √∫ltimos a√±os, es el nivel de detalle.

Tengo que representar en un diagrama TODO el sistema? Todos los comportamientos? Todas las clases? Todos los atributos y m√©todos? NO. Antiguamente SI!!!! 

Por que el diagrama era interpretado por herramientas, que generaban c√≥digo, etc. Hoy en d√≠a NO. Hoy en d√≠a los diagramas son para humanos. Y creo un diagrama para contar lo que me interesa contar. Y para lo mismo, quiz√°s hago 5 diagramas. Con m√°s nivel de detalle o menos nivel de detalle; explicando unos casos de uso u otros.

## Inicio de un proyecto de software 

No se empieza por los requisitos. Se empieza por entender qui√©nes son los actores del sistema, y qu√© necesitan del sistema: CASOS DE USO (USE CASES).

UML define un diagrama espec√≠fico para esto: DIAGRAMA DE CASOS DE USO (USE CASE DIAGRAM).

Lamentablemente Mermaid no soporta este diagrama. As√≠ que usaremos PlantUML para ello.

```plantuml
@startuml
left to right direction

skinparam actorStyle awesome

actor "Cliente" as cliente
actor "El que mete los billetes" as cajero
actor "Mantenimiento" as mantenimiento
actor "Backend del banco" as banco << System >>

package "Cajero Autom√°tico" {
  usecase "Identificarse" as identificarse
  usecase "Retirar dinero" as retirarDinero
  usecase "Ingresar dinero" as ingresarDinero
  usecase "Consultar saldo" as consultarSaldo
  usecase "Reponer efectivo" as reponerEfectivo
  usecase "Realizar mantenimiento" as realizarMantenimiento
}

cliente --> identificarse
cliente --> retirarDinero
cliente --> ingresarDinero
cliente --> consultarSaldo
cajero --> reponerEfectivo
retirarDinero --> identificarse
mantenimiento --> realizarMantenimiento
retirarDinero --> banco : "Solicita autorizaci√≥n"
ingresarDinero --> banco : "Actualiza saldo"
consultarSaldo --> banco : "Consulta saldo"
identificarse --> banco : "Verifica identidad"

@enduml
```

> Ejemplo: Un diagrama de casos de uso para el software que va instalado en un cajero autom√°tico (ATM) del banco.

## Requisitos:

- Caso de uso 1: Identificarse
  Requisitos associados:
  - El sistema debe permitir a los clientes identificarse mediante una tarjeta bancaria y un PIN.
  - El cliente puede intentar identificarse hasta 3 veces antes de bloquear la tarjeta.
  - En la tarjeta est√° el pin, pero no vale solamente con eso, es necesario solicitar confirmaci√≥n al backend del banco, caso que la tarjeta haya sido bloqueada/revocada por seguridad.
  - El pin tendr√° 4 d√≠gitos.

## Diagrama de secuencia para la operaci√≥n "Sacar dinero"

Este diagrama debe incluir Toda la secuencia Real de operaciones que se llevan a cabo en el sistema para realizar la operaci√≥n de sacar dinero? NO. Contar√© solo lo que me interesa contar.... hablar√© de los escenarios que me interese hablar. No estoy escribiendo el C√ìDIGO del sistema.

En el c√≥digo debo tener TODO lo que efectivamente hace el sistema. En el diagrama solo lo que me interesa contar.

> Happy path: El camino feliz, el escenario principal.

->>     =       - > >     Mensaje s√≠ncrono, que queda esperando respuesta.
-->>                      Mensaje as√≠ncrono, no queda esperando respuesta.

```mermaid

sequenceDiagram

actor            U as "Usuario"
participant      CA as "Cajero Autom√°tico"
participant      S as "Servidor en el Banco"

U  ->> +CA:      üí≥ Inserta tarjeta
CA ->> U:        üîê Solicita PIN
U  ->> CA:       üî¢ Introduce PIN
CA ->> +S:       üì© Valida PIN y solicita Aprobaci√≥n
S  -->> -CA:     ‚úÖ PIN v√°lido y Aprobaci√≥n concedida
CA ->> U:        Solicita Operaci√≥n
U  ->> CA:       Selecciona "Sacar Dinero"
CA ->> U:        Solicita Cantidad
U  ->> CA:       Introduce Cantidad
CA ->> +S:       üì© Solicita Aprobaci√≥n de Retiro
S  -->> -CA:     ‚úÖ Aprobaci√≥n concedida
CA ->> U:        Dispensa Dinero üíµ
U  ->> CA:       Retira Dinero
CA ->> U:        ¬øDesea otra operaci√≥n?
U  ->> CA:       No
CA -->> -U:      Expulsa Tarjeta üí≥

```

> Ejemplo con el usuario metiendo mal el pin 3 veces

```mermaid
sequenceDiagram
actor            U as "Usuario"
participant      CA as "Cajero Autom√°tico"
participant      S as "Servidor en el Banco"
U  ->> +CA:      üí≥ Inserta tarjeta
CA ->> U:        üîê Solicita PIN
U  ->> CA:       üî¢ Introduce PIN
CA ->> +S:       üì© Valida PIN y solicita Aprobaci√≥n
S  -->> -CA:     ‚ùå PIN inv√°lido
CA ->> U:        ‚ùå PIN inv√°lido. Intentos restantes: 2
U  ->> CA:       üî¢ Introduce PIN
CA ->> +S:       üì© Valida PIN y solicita Aprobaci√≥n
S  -->> -CA:     ‚ùå PIN inv√°lido
CA ->> U:        ‚ùå PIN inv√°lido. Intentos restantes: 1
U  ->> CA:       üî¢ Introduce PIN
CA ->> +S:       üì© Valida PIN y solicita Aprobaci√≥n
S  -->> -CA:     ‚ùå PIN inv√°lido
CA ->> U:        ‚ùå PIN inv√°lido. Tarjeta bloqueada por seguridad.
CA -->> -U:      Expulsa Tarjeta üí≥
```

> Ejemplo: No hay billetes suficientes en el cajero

```mermaid
sequenceDiagram
actor            U as "Usuario"
participant      CA as "Cajero Autom√°tico"
participant      S as "Servidor en el Banco"
U  ->> +CA:      üí≥ Inserta tarjeta
CA ->> U:        üîê Solicita PIN
U  ->> CA:       üî¢ Introduce PIN
CA ->> +S:       üì© Valida PIN y solicita Aprobaci√≥n
S  -->> -CA:     ‚úÖ PIN v√°lido y Aprobaci√≥n concedida
CA ->> U:        Solicita Operaci√≥n
U  ->> CA:       Selecciona "Sacar Dinero"
CA ->> U:        Solicita Cantidad
U  ->> CA:       Introduce Cantidad
CA ->> CA:       Verifica disponibilidad de billetes
CA ->> U:        ‚ùå No hay suficientes billetes disponibles
CA ->> U:        ¬øDesea otra operaci√≥n?
U  ->> CA:       No
CA -->> -U:      Expulsa Tarjeta üí≥
```

> Ejemplo: El usuario no tiene saldo suficiente

```mermaid
sequenceDiagram
actor            U as "Usuario"
participant      CA as "Cajero Autom√°tico"
participant      S as "Servidor en el Banco"
U  ->> +CA:      üí≥ Inserta tarjeta
CA ->> U:        üîê Solicita PIN
U  ->> CA:       üî¢ Introduce PIN
CA ->> +S:       üì© Valida PIN y solicita Aprobaci√≥n
S  -->> -CA:     ‚úÖ PIN v√°lido y Aprobaci√≥n concedida
CA ->> U:        Solicita Operaci√≥n
U  ->> CA:       Selecciona "Sacar Dinero"
CA ->> U:        Solicita Cantidad
U  ->> CA:       Introduce Cantidad
CA ->> +S:       üì© Solicita Aprobaci√≥n de Retiro
S  -->> -CA:     ‚ùå Saldo insuficiente
CA ->> U:        ‚ùå No tiene saldo suficiente en su cuenta
CA ->> U:        ¬øDesea otra operaci√≥n?
U  ->> CA:       No
CA -->> -U:      Expulsa Tarjeta üí≥
```

## Diagramas m√°s complejos!

Esos son diagramas muy simplones. Puedo llegar a mucho m√°s nivel de detalle.

No empiezo con estos diagramas. No tiene sentido. Tenemos que hacernos, con la operativa, con los detalles, con el lenguaje!

```mermaid

sequenceDiagram

    actor                   U as Usuario
    participant             C as Cajero
    participant             S as Servidor

    U->>C:                  üí≥ Insertar tarjeta

    rect rgb(255,240,230)
        note left of C:                 LECTURA DE LA TARJETA
        critical                        Leer tarjeta
        option                          Tarjeta caducada
            rect rgb(255,230,200)
                break                   No se puede procesar la operaci√≥n
                    C-->>U:                 Tarjeta caducada
                    C-->>U:                 üí≥ Entrega la tarjeta
                end
            end
        option                          Error al leer la tarjeta
            rect rgb(255,230,230)
                break               
                    C-->>U:                 Tarjeta no legible
                    C-->>U:                 üí≥ Entrega la tarjeta
                end
            end
        end
    end
    rect rgb(255,255,230)
        note left of S:                 PIN
        loop                            Hasta 3 intentos si el pin no es v√°lido
            rect rgb(235,235,200)
                note left of C:         Obtenci√≥n del PIN
                C-->>U:                 Solicitar PIN
                critical                Esperar el PIN
                    U->>C:                  Escribe su PIN
                option                  No se ha introducido el PIN en 30 segundos
                    rect rgb(255,230,230)
                        break
                            C->>U:          No se puede procesar la operaci√≥n
                            C->>U:          üí≥ Entrega la tarjeta
                        end
                    end
                end
            end 
            rect rgb(235,235,180)
                note left of S:         Validaci√≥n del PIN
                C->>+S:                 Solicitar validaci√≥n del PIN de la tarjeta
                critical                Validar PIN
                        S-->>C:         PIN correcto
                option                  PIN incorrecto
                        S-->>C:         PIN incorrecto
                option                  Servidor con problemas internos
                    S-->>-C:             Notifica problemas internos
                option                  Timeout
                    note left of S:     El servidor no contesta
                end

                opt                     Si ha habido timeout o problemas internos
            rect rgb(255,230,230)
                    break               No se puede validar el PIN
                        C-->>U:         üí≥ Entrega la tarjeta
                        C-->>U:         No se puede procesar la operaci√≥n
                    end
                    end
                end
            end 
        end

            rect rgb(235,235,180)
        critical                Si no se ha conseguido un PIN correcto
            rect rgb(255,230,230)
                    break               
                        C-->>U:         üí≥ Entrega la tarjeta
                        C-->>U:         No se puede procesar la operaci√≥n
                    end
                end
            end
            end
    end 

    rect rgb(240,240,255)
        note left of S:     SACAR DINERO

        loop Hasta 3 intentos si la cantidad no es v√°lida
            rect rgb(230,230,255)
                note left of C:         Cantidad
                C-->>U:                 Solicitar cantidad
                critical                     Esperar la cantidad la Cantidad
                    U->>C:                  Escribe la cantidad
                    opt                 Si no hay suficiente dinero o <BR/>no se le puede entregar
                        C-->>U:         No hay tanto dinero o <BR/>debe introducir una cantidad <BR/>m√∫ltiplo del tipo de<BR/> billetes disponibles
                    end
                option                 No se ha introducido la cantidad en 30 segundos
            rect rgb(255,230,230)
                        break                 
                            C-->>U:                 No se puede procesar la operaci√≥n
                            C-->>U:                 üí≥ Entrega la tarjeta
                        end
                        end
                end
            end 
            rect rgb(230,230,255)

        critical                Confirmar con el servidor
        C->>S:                 Retirar importe solicitado
        S-->>C:                OK
        option                 No hay suficiente dinero en la cuenta
            S-->>C:            No hay suficiente dinero
            C-->>U:            No hay suficiente dinero
        option                Error del servidor
            rect rgb(255,230,230)
            S-->>C:            Error del servidor
            break                   Sistema no operativo
                C->>U:                 No se puede procesar la operaci√≥n
                C->>U:                 üí≥ Entrega la tarjeta
            end
            end
        option              Timeout
            rect rgb(255,230,230)
            break                   Sistema no operativo
                C->>U:                 No se puede procesar la operaci√≥n
                C->>U:                 üí≥ Entrega la tarjeta
            end
            end
        end
        end
        end
                    rect rgb(230,230,255)
        critical                Si no se ha conseguido una cantidad Correcta
            rect rgb(255,230,230)
                    break               
                        C-->>U:         üí≥ Entrega la tarjeta
                        C-->>U:         No se puede procesar la operaci√≥n
                    end
                end
            end
            end

        C-->>U:                 üí≥ Entrega la tarjeta
        C-->>U:                 üí∞ Entrega el dinero
    end

```

---

## Lenguajes formales vs Lenguajes naturales

Lenguajes naturales, los que usamos los humanos: Espa√±ol, Ingl√©s, Chino, etc.
En los lenguajes naturales, la gram√°tica la pisamos de forma continua. Nos saltamos reglas, inventamos palabras, usamos expresiones que no existen, etc. Y la gente me entiende perfectamente.
Los lenguajes formales son lenguajes con una gram√°tica estricta.

    Matem√°tico:   3 + 5 = 8
                  3 = 5 8 +

                  tres m√°s cinco es igual a ocho